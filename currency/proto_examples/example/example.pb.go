// Code generated by protoc-gen-go. DO NOT EDIT.
// source: example.proto

package example

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	any "github.com/golang/protobuf/ptypes/any"
	status "google.golang.org/genproto/googleapis/rpc/status"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status1 "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Enumerations
type Diet int32

const (
	Diet_VEGAN       Diet = 0
	Diet_VEGITARIAN  Diet = 1
	Diet_PESCATARIAN Diet = 2
	Diet_GLUTEN_FREE Diet = 3
	Diet_DAIRY_FREE  Diet = 4
)

var Diet_name = map[int32]string{
	0: "VEGAN",
	1: "VEGITARIAN",
	2: "PESCATARIAN",
	3: "GLUTEN_FREE",
	4: "DAIRY_FREE",
}

var Diet_value = map[string]int32{
	"VEGAN":       0,
	"VEGITARIAN":  1,
	"PESCATARIAN": 2,
	"GLUTEN_FREE": 3,
	"DAIRY_FREE":  4,
}

func (x Diet) String() string {
	return proto.EnumName(Diet_name, int32(x))
}

func (Diet) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_15a1dc8d40dadaa6, []int{0}
}

type Recipie_Available int32

const (
	Recipie_ALL_DAY Recipie_Available = 0
	Recipie_LUNCH   Recipie_Available = 1
	Recipie_BRUNCH  Recipie_Available = 1
	Recipie_DINNER  Recipie_Available = 2
)

var Recipie_Available_name = map[int32]string{
	0: "ALL_DAY",
	1: "LUNCH",
	// Duplicate value: 1: "BRUNCH",
	2: "DINNER",
}

var Recipie_Available_value = map[string]int32{
	"ALL_DAY": 0,
	"LUNCH":   1,
	"BRUNCH":  1,
	"DINNER":  2,
}

func (x Recipie_Available) String() string {
	return proto.EnumName(Recipie_Available_name, int32(x))
}

func (Recipie_Available) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_15a1dc8d40dadaa6, []int{5, 0}
}

// Simple message with scalar types
type Product struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Description          string   `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Price                float64  `protobuf:"fixed64,4,opt,name=price,proto3" json:"price,omitempty"`
	Sku                  string   `protobuf:"bytes,5,opt,name=sku,proto3" json:"sku,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Product) Reset()         { *m = Product{} }
func (m *Product) String() string { return proto.CompactTextString(m) }
func (*Product) ProtoMessage()    {}
func (*Product) Descriptor() ([]byte, []int) {
	return fileDescriptor_15a1dc8d40dadaa6, []int{0}
}

func (m *Product) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Product.Unmarshal(m, b)
}
func (m *Product) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Product.Marshal(b, m, deterministic)
}
func (m *Product) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Product.Merge(m, src)
}
func (m *Product) XXX_Size() int {
	return xxx_messageInfo_Product.Size(m)
}
func (m *Product) XXX_DiscardUnknown() {
	xxx_messageInfo_Product.DiscardUnknown(m)
}

var xxx_messageInfo_Product proto.InternalMessageInfo

func (m *Product) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Product) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Product) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Product) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *Product) GetSku() string {
	if m != nil {
		return m.Sku
	}
	return ""
}

// Handling dates
// Dates are not part of the ProtocolBuffers specification, to work round this we can define a message
// called DateTime which contains the number of nanoseconds since 1/1/1970. Mostly all programming
// languages will be able to convert to and from this date
type DateTime struct {
	Nanoseconds          int64    `protobuf:"varint,1,opt,name=nanoseconds,proto3" json:"nanoseconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DateTime) Reset()         { *m = DateTime{} }
func (m *DateTime) String() string { return proto.CompactTextString(m) }
func (*DateTime) ProtoMessage()    {}
func (*DateTime) Descriptor() ([]byte, []int) {
	return fileDescriptor_15a1dc8d40dadaa6, []int{1}
}

func (m *DateTime) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DateTime.Unmarshal(m, b)
}
func (m *DateTime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DateTime.Marshal(b, m, deterministic)
}
func (m *DateTime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DateTime.Merge(m, src)
}
func (m *DateTime) XXX_Size() int {
	return xxx_messageInfo_DateTime.Size(m)
}
func (m *DateTime) XXX_DiscardUnknown() {
	xxx_messageInfo_DateTime.DiscardUnknown(m)
}

var xxx_messageInfo_DateTime proto.InternalMessageInfo

func (m *DateTime) GetNanoseconds() int64 {
	if m != nil {
		return m.Nanoseconds
	}
	return 0
}

// Embedding messages
// Messages can be used as types in other messages, they can either use
// external messages or embed their own messages.
type Order struct {
	Product              *Product        `protobuf:"bytes,1,opt,name=product,proto3" json:"product,omitempty"`
	OrderDate            *DateTime       `protobuf:"bytes,2,opt,name=order_date,json=orderDate,proto3" json:"order_date,omitempty"`
	Customer             *Order_Customer `protobuf:"bytes,3,opt,name=customer,proto3" json:"customer,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_15a1dc8d40dadaa6, []int{2}
}

func (m *Order) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Order.Unmarshal(m, b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Order.Marshal(b, m, deterministic)
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return xxx_messageInfo_Order.Size(m)
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetProduct() *Product {
	if m != nil {
		return m.Product
	}
	return nil
}

func (m *Order) GetOrderDate() *DateTime {
	if m != nil {
		return m.OrderDate
	}
	return nil
}

func (m *Order) GetCustomer() *Order_Customer {
	if m != nil {
		return m.Customer
	}
	return nil
}

type Order_Customer struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Phone                string   `protobuf:"bytes,2,opt,name=phone,proto3" json:"phone,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Order_Customer) Reset()         { *m = Order_Customer{} }
func (m *Order_Customer) String() string { return proto.CompactTextString(m) }
func (*Order_Customer) ProtoMessage()    {}
func (*Order_Customer) Descriptor() ([]byte, []int) {
	return fileDescriptor_15a1dc8d40dadaa6, []int{2, 0}
}

func (m *Order_Customer) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Order_Customer.Unmarshal(m, b)
}
func (m *Order_Customer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Order_Customer.Marshal(b, m, deterministic)
}
func (m *Order_Customer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order_Customer.Merge(m, src)
}
func (m *Order_Customer) XXX_Size() int {
	return xxx_messageInfo_Order_Customer.Size(m)
}
func (m *Order_Customer) XXX_DiscardUnknown() {
	xxx_messageInfo_Order_Customer.DiscardUnknown(m)
}

var xxx_messageInfo_Order_Customer proto.InternalMessageInfo

func (m *Order_Customer) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Order_Customer) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

// Lists
// Messages can contain lists of scalar types or messages using the repeated keyword
type ServerOrders struct {
	Server               *ServerOrders_Server `protobuf:"bytes,1,opt,name=server,proto3" json:"server,omitempty"`
	Order                []*Order             `protobuf:"bytes,2,rep,name=order,proto3" json:"order,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ServerOrders) Reset()         { *m = ServerOrders{} }
func (m *ServerOrders) String() string { return proto.CompactTextString(m) }
func (*ServerOrders) ProtoMessage()    {}
func (*ServerOrders) Descriptor() ([]byte, []int) {
	return fileDescriptor_15a1dc8d40dadaa6, []int{3}
}

func (m *ServerOrders) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerOrders.Unmarshal(m, b)
}
func (m *ServerOrders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerOrders.Marshal(b, m, deterministic)
}
func (m *ServerOrders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerOrders.Merge(m, src)
}
func (m *ServerOrders) XXX_Size() int {
	return xxx_messageInfo_ServerOrders.Size(m)
}
func (m *ServerOrders) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerOrders.DiscardUnknown(m)
}

var xxx_messageInfo_ServerOrders proto.InternalMessageInfo

func (m *ServerOrders) GetServer() *ServerOrders_Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *ServerOrders) GetOrder() []*Order {
	if m != nil {
		return m.Order
	}
	return nil
}

type ServerOrders_Server struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerOrders_Server) Reset()         { *m = ServerOrders_Server{} }
func (m *ServerOrders_Server) String() string { return proto.CompactTextString(m) }
func (*ServerOrders_Server) ProtoMessage()    {}
func (*ServerOrders_Server) Descriptor() ([]byte, []int) {
	return fileDescriptor_15a1dc8d40dadaa6, []int{3, 0}
}

func (m *ServerOrders_Server) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerOrders_Server.Unmarshal(m, b)
}
func (m *ServerOrders_Server) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerOrders_Server.Marshal(b, m, deterministic)
}
func (m *ServerOrders_Server) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerOrders_Server.Merge(m, src)
}
func (m *ServerOrders_Server) XXX_Size() int {
	return xxx_messageInfo_ServerOrders_Server.Size(m)
}
func (m *ServerOrders_Server) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerOrders_Server.DiscardUnknown(m)
}

var xxx_messageInfo_ServerOrders_Server proto.InternalMessageInfo

func (m *ServerOrders_Server) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Maps
// messages can contain maps map<key, value>
type ProductPrice struct {
	// maps can contain scalar types as values
	CurrencyPrice map[string]float64 `protobuf:"bytes,1,rep,name=currency_price,json=currencyPrice,proto3" json:"currency_price,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	// maps can contain messages as values
	CurrencyLastChangeDate map[string]*DateTime `protobuf:"bytes,2,rep,name=currency_last_change_date,json=currencyLastChangeDate,proto3" json:"currency_last_change_date,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral   struct{}             `json:"-"`
	XXX_unrecognized       []byte               `json:"-"`
	XXX_sizecache          int32                `json:"-"`
}

func (m *ProductPrice) Reset()         { *m = ProductPrice{} }
func (m *ProductPrice) String() string { return proto.CompactTextString(m) }
func (*ProductPrice) ProtoMessage()    {}
func (*ProductPrice) Descriptor() ([]byte, []int) {
	return fileDescriptor_15a1dc8d40dadaa6, []int{4}
}

func (m *ProductPrice) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ProductPrice.Unmarshal(m, b)
}
func (m *ProductPrice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ProductPrice.Marshal(b, m, deterministic)
}
func (m *ProductPrice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductPrice.Merge(m, src)
}
func (m *ProductPrice) XXX_Size() int {
	return xxx_messageInfo_ProductPrice.Size(m)
}
func (m *ProductPrice) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductPrice.DiscardUnknown(m)
}

var xxx_messageInfo_ProductPrice proto.InternalMessageInfo

func (m *ProductPrice) GetCurrencyPrice() map[string]float64 {
	if m != nil {
		return m.CurrencyPrice
	}
	return nil
}

func (m *ProductPrice) GetCurrencyLastChangeDate() map[string]*DateTime {
	if m != nil {
		return m.CurrencyLastChangeDate
	}
	return nil
}

type Recipie struct {
	Name                 string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Suitability          []Diet            `protobuf:"varint,2,rep,packed,name=suitability,proto3,enum=Diet" json:"suitability,omitempty"`
	Available            Recipie_Available `protobuf:"varint,3,opt,name=available,proto3,enum=Recipie_Available" json:"available,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Recipie) Reset()         { *m = Recipie{} }
func (m *Recipie) String() string { return proto.CompactTextString(m) }
func (*Recipie) ProtoMessage()    {}
func (*Recipie) Descriptor() ([]byte, []int) {
	return fileDescriptor_15a1dc8d40dadaa6, []int{5}
}

func (m *Recipie) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Recipie.Unmarshal(m, b)
}
func (m *Recipie) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Recipie.Marshal(b, m, deterministic)
}
func (m *Recipie) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Recipie.Merge(m, src)
}
func (m *Recipie) XXX_Size() int {
	return xxx_messageInfo_Recipie.Size(m)
}
func (m *Recipie) XXX_DiscardUnknown() {
	xxx_messageInfo_Recipie.DiscardUnknown(m)
}

var xxx_messageInfo_Recipie proto.InternalMessageInfo

func (m *Recipie) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Recipie) GetSuitability() []Diet {
	if m != nil {
		return m.Suitability
	}
	return nil
}

func (m *Recipie) GetAvailable() Recipie_Available {
	if m != nil {
		return m.Available
	}
	return Recipie_ALL_DAY
}

type ErrorMessage struct {
	Error                *status.Status `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ErrorMessage) Reset()         { *m = ErrorMessage{} }
func (m *ErrorMessage) String() string { return proto.CompactTextString(m) }
func (*ErrorMessage) ProtoMessage()    {}
func (*ErrorMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_15a1dc8d40dadaa6, []int{6}
}

func (m *ErrorMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ErrorMessage.Unmarshal(m, b)
}
func (m *ErrorMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ErrorMessage.Marshal(b, m, deterministic)
}
func (m *ErrorMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ErrorMessage.Merge(m, src)
}
func (m *ErrorMessage) XXX_Size() int {
	return xxx_messageInfo_ErrorMessage.Size(m)
}
func (m *ErrorMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ErrorMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ErrorMessage proto.InternalMessageInfo

func (m *ErrorMessage) GetError() *status.Status {
	if m != nil {
		return m.Error
	}
	return nil
}

type Ingredients struct {
	Name                 string     `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	NutricionalInfo      []*any.Any `protobuf:"bytes,2,rep,name=nutricional_info,json=nutricionalInfo,proto3" json:"nutricional_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Ingredients) Reset()         { *m = Ingredients{} }
func (m *Ingredients) String() string { return proto.CompactTextString(m) }
func (*Ingredients) ProtoMessage()    {}
func (*Ingredients) Descriptor() ([]byte, []int) {
	return fileDescriptor_15a1dc8d40dadaa6, []int{7}
}

func (m *Ingredients) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Ingredients.Unmarshal(m, b)
}
func (m *Ingredients) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Ingredients.Marshal(b, m, deterministic)
}
func (m *Ingredients) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ingredients.Merge(m, src)
}
func (m *Ingredients) XXX_Size() int {
	return xxx_messageInfo_Ingredients.Size(m)
}
func (m *Ingredients) XXX_DiscardUnknown() {
	xxx_messageInfo_Ingredients.DiscardUnknown(m)
}

var xxx_messageInfo_Ingredients proto.InternalMessageInfo

func (m *Ingredients) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Ingredients) GetNutricionalInfo() []*any.Any {
	if m != nil {
		return m.NutricionalInfo
	}
	return nil
}

// Define messages which can be of different fixed types
type SubscribeOrderResponse struct {
	// message will contain one of the two types
	// setting one of these types automatically clears all other members
	// only the last field you set will have a value
	//
	// Types that are valid to be assigned to Message:
	//	*SubscribeOrderResponse_Order
	//	*SubscribeOrderResponse_Error
	Message              isSubscribeOrderResponse_Message `protobuf_oneof:"message"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *SubscribeOrderResponse) Reset()         { *m = SubscribeOrderResponse{} }
func (m *SubscribeOrderResponse) String() string { return proto.CompactTextString(m) }
func (*SubscribeOrderResponse) ProtoMessage()    {}
func (*SubscribeOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_15a1dc8d40dadaa6, []int{8}
}

func (m *SubscribeOrderResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubscribeOrderResponse.Unmarshal(m, b)
}
func (m *SubscribeOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubscribeOrderResponse.Marshal(b, m, deterministic)
}
func (m *SubscribeOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeOrderResponse.Merge(m, src)
}
func (m *SubscribeOrderResponse) XXX_Size() int {
	return xxx_messageInfo_SubscribeOrderResponse.Size(m)
}
func (m *SubscribeOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeOrderResponse proto.InternalMessageInfo

type isSubscribeOrderResponse_Message interface {
	isSubscribeOrderResponse_Message()
}

type SubscribeOrderResponse_Order struct {
	Order *Order `protobuf:"bytes,1,opt,name=order,proto3,oneof"`
}

type SubscribeOrderResponse_Error struct {
	Error *status.Status `protobuf:"bytes,2,opt,name=error,proto3,oneof"`
}

func (*SubscribeOrderResponse_Order) isSubscribeOrderResponse_Message() {}

func (*SubscribeOrderResponse_Error) isSubscribeOrderResponse_Message() {}

func (m *SubscribeOrderResponse) GetMessage() isSubscribeOrderResponse_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *SubscribeOrderResponse) GetOrder() *Order {
	if x, ok := m.GetMessage().(*SubscribeOrderResponse_Order); ok {
		return x.Order
	}
	return nil
}

func (m *SubscribeOrderResponse) GetError() *status.Status {
	if x, ok := m.GetMessage().(*SubscribeOrderResponse_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SubscribeOrderResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SubscribeOrderResponse_Order)(nil),
		(*SubscribeOrderResponse_Error)(nil),
	}
}

func init() {
	proto.RegisterEnum("Diet", Diet_name, Diet_value)
	proto.RegisterEnum("Recipie_Available", Recipie_Available_name, Recipie_Available_value)
	proto.RegisterType((*Product)(nil), "Product")
	proto.RegisterType((*DateTime)(nil), "DateTime")
	proto.RegisterType((*Order)(nil), "Order")
	proto.RegisterType((*Order_Customer)(nil), "Order.Customer")
	proto.RegisterType((*ServerOrders)(nil), "ServerOrders")
	proto.RegisterType((*ServerOrders_Server)(nil), "ServerOrders.Server")
	proto.RegisterType((*ProductPrice)(nil), "ProductPrice")
	proto.RegisterMapType((map[string]*DateTime)(nil), "ProductPrice.CurrencyLastChangeDateEntry")
	proto.RegisterMapType((map[string]float64)(nil), "ProductPrice.CurrencyPriceEntry")
	proto.RegisterType((*Recipie)(nil), "Recipie")
	proto.RegisterType((*ErrorMessage)(nil), "ErrorMessage")
	proto.RegisterType((*Ingredients)(nil), "Ingredients")
	proto.RegisterType((*SubscribeOrderResponse)(nil), "SubscribeOrderResponse")
}

func init() {
	proto.RegisterFile("example.proto", fileDescriptor_15a1dc8d40dadaa6)
}

var fileDescriptor_15a1dc8d40dadaa6 = []byte{
	// 789 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x54, 0x5d, 0x6f, 0xdb, 0x36,
	0x14, 0x8d, 0xe4, 0xd8, 0x8e, 0xaf, 0x13, 0x47, 0x20, 0x82, 0xd6, 0xf5, 0x8a, 0xcd, 0xd0, 0xcb,
	0xbc, 0xae, 0x53, 0x0a, 0x6f, 0x0f, 0xc5, 0x5e, 0x3a, 0xd5, 0xd6, 0x52, 0x03, 0x9e, 0x17, 0xd0,
	0x69, 0x81, 0x3e, 0x19, 0xb4, 0xc4, 0x38, 0x44, 0x1d, 0x52, 0x20, 0xa5, 0xac, 0x7e, 0xde, 0x9f,
	0xda, 0x7e, 0xc8, 0xfe, 0xcf, 0xc0, 0x0f, 0x25, 0x0a, 0xe6, 0xee, 0x8d, 0xe7, 0xde, 0xa3, 0xa3,
	0x7b, 0x0f, 0xef, 0x25, 0x9c, 0xd0, 0xcf, 0xe4, 0x36, 0xdf, 0xd2, 0x28, 0x97, 0xa2, 0x10, 0x83,
	0xa7, 0x1b, 0x21, 0x36, 0x5b, 0x7a, 0x2e, 0xf3, 0xf4, 0x5c, 0x15, 0xa4, 0x28, 0x95, 0x4b, 0x3c,
	0x73, 0x09, 0x83, 0xd6, 0xe5, 0xf5, 0x39, 0xe1, 0x3b, 0x9b, 0x0a, 0xff, 0x80, 0xf6, 0xa5, 0x14,
	0x59, 0x99, 0x16, 0xa8, 0x07, 0x3e, 0xcb, 0xfa, 0xde, 0xd0, 0x1b, 0x35, 0xb1, 0xcf, 0x32, 0x84,
	0xe0, 0x90, 0x93, 0x5b, 0xda, 0xf7, 0x87, 0xde, 0xa8, 0x83, 0xcd, 0x19, 0x0d, 0xa1, 0x9b, 0x51,
	0x95, 0x4a, 0x96, 0x17, 0x4c, 0xf0, 0x7e, 0xc3, 0xa4, 0xea, 0x21, 0x74, 0x06, 0xcd, 0x5c, 0xb2,
	0x94, 0xf6, 0x0f, 0x87, 0xde, 0xc8, 0xc3, 0x16, 0xa0, 0x00, 0x1a, 0xea, 0x53, 0xd9, 0x6f, 0x1a,
	0xbe, 0x3e, 0x86, 0x2f, 0xe1, 0x68, 0x4a, 0x0a, 0x7a, 0xc5, 0xac, 0x2a, 0x27, 0x5c, 0x28, 0x9a,
	0x0a, 0x9e, 0x29, 0x53, 0x42, 0x03, 0xd7, 0x43, 0xe1, 0x5f, 0x1e, 0x34, 0x7f, 0x97, 0x19, 0x95,
	0x28, 0x84, 0x76, 0x6e, 0x0b, 0x36, 0xbc, 0xee, 0xf8, 0x28, 0x72, 0x0d, 0xe0, 0x2a, 0x81, 0x46,
	0x00, 0x42, 0x93, 0x57, 0x19, 0x29, 0x6c, 0xfd, 0xdd, 0x71, 0x27, 0xaa, 0x7e, 0x87, 0x3b, 0x26,
	0xa9, 0x21, 0xfa, 0x1e, 0x8e, 0xd2, 0x52, 0x15, 0xe2, 0x96, 0x4a, 0xd3, 0x4c, 0x77, 0x7c, 0x1a,
	0x99, 0xff, 0x44, 0x13, 0x17, 0xc6, 0xf7, 0x84, 0xc1, 0x4f, 0x70, 0x54, 0x45, 0xef, 0xcd, 0xf1,
	0x6a, 0xe6, 0xe8, 0xd6, 0x6f, 0x04, 0xaf, 0x1c, 0xb3, 0x20, 0xfc, 0x0c, 0xc7, 0x4b, 0x2a, 0xef,
	0xa8, 0x34, 0xba, 0x0a, 0xbd, 0x84, 0x96, 0x32, 0xd8, 0xd5, 0x7f, 0x16, 0xd5, 0xd3, 0x0e, 0x60,
	0xc7, 0x41, 0xcf, 0xa1, 0x69, 0xaa, 0xed, 0xfb, 0xc3, 0xc6, 0xa8, 0x3b, 0x6e, 0xd9, 0xea, 0xb0,
	0x0d, 0x0e, 0x9e, 0x43, 0xcb, 0xf2, 0xf7, 0xd5, 0x13, 0xfe, 0xe3, 0xc3, 0xb1, 0xf3, 0xe6, 0xd2,
	0xdc, 0xc2, 0x05, 0xf4, 0xd2, 0x52, 0x4a, 0xca, 0xd3, 0xdd, 0xca, 0x5e, 0x92, 0x67, 0x54, 0x87,
	0x51, 0x9d, 0x16, 0x4d, 0x1c, 0xc7, 0xa0, 0x84, 0x17, 0x72, 0x87, 0x4f, 0xd2, 0x7a, 0x0c, 0x65,
	0xf0, 0xec, 0x5e, 0x68, 0x4b, 0x54, 0xb1, 0x4a, 0x6f, 0x08, 0xdf, 0xd0, 0xca, 0x6f, 0xad, 0xf9,
	0xdd, 0x7e, 0xcd, 0x39, 0x51, 0xc5, 0xc4, 0x90, 0xb5, 0xff, 0x56, 0xfc, 0x49, 0xba, 0x37, 0x39,
	0xf8, 0x05, 0xd0, 0x7f, 0x4b, 0xd1, 0xa3, 0xf4, 0x89, 0xee, 0x5c, 0xa3, 0xfa, 0xa8, 0x7d, 0xbf,
	0x23, 0xdb, 0xd2, 0xfa, 0xee, 0x61, 0x0b, 0x7e, 0xf6, 0x5f, 0x7b, 0x83, 0x2b, 0xf8, 0xea, 0x7f,
	0x7e, 0xbc, 0x47, 0xea, 0x9b, 0xba, 0xd4, 0xa3, 0xa1, 0x79, 0x50, 0x0d, 0xff, 0xf6, 0xa0, 0x8d,
	0x69, 0xca, 0x72, 0x46, 0xf7, 0xce, 0xc1, 0xb7, 0xd0, 0x55, 0x25, 0x2b, 0xc8, 0x9a, 0x6d, 0x59,
	0xb1, 0x33, 0x7e, 0xf4, 0xc6, 0xcd, 0x68, 0xca, 0x68, 0x81, 0xeb, 0x19, 0xf4, 0x0a, 0x3a, 0xe4,
	0x8e, 0xb0, 0x2d, 0x59, 0x6f, 0xa9, 0x19, 0xbf, 0xde, 0x18, 0x45, 0x4e, 0x39, 0x8a, 0xab, 0x0c,
	0x7e, 0x20, 0x85, 0x6f, 0xa0, 0x73, 0x1f, 0x47, 0x5d, 0x68, 0xc7, 0xf3, 0xf9, 0x6a, 0x1a, 0x7f,
	0x0c, 0x0e, 0x50, 0x07, 0x9a, 0xf3, 0xf7, 0x8b, 0xc9, 0xbb, 0xc0, 0x43, 0x00, 0xad, 0xb7, 0xf8,
	0xe1, 0x3c, 0x9d, 0x2d, 0x16, 0x09, 0x0e, 0xfc, 0x81, 0x1f, 0x78, 0xe1, 0x6b, 0x38, 0x4e, 0xa4,
	0x14, 0xf2, 0x37, 0xaa, 0x14, 0xd9, 0x50, 0x34, 0x82, 0x26, 0xd5, 0xd8, 0x0d, 0x23, 0x8a, 0xec,
	0x53, 0x11, 0xc9, 0x3c, 0x8d, 0x96, 0xe6, 0x0d, 0xc1, 0x96, 0x10, 0xae, 0xa1, 0x3b, 0xe3, 0x1b,
	0x49, 0x33, 0x46, 0x79, 0xa1, 0xf6, 0x36, 0xfe, 0x06, 0x02, 0x5e, 0x16, 0x92, 0xa5, 0x4c, 0x70,
	0xb2, 0x5d, 0x31, 0x7e, 0x2d, 0xdc, 0x34, 0x9c, 0x55, 0xba, 0xd5, 0x13, 0x14, 0xc5, 0x7c, 0x87,
	0x4f, 0x6b, 0xec, 0x19, 0xbf, 0x16, 0xa1, 0x80, 0x27, 0xcb, 0x72, 0xad, 0x1f, 0x93, 0x35, 0xb5,
	0x83, 0x4e, 0x55, 0x2e, 0xb8, 0xa2, 0xe8, 0xeb, 0x6a, 0x0f, 0x6c, 0x9d, 0x6e, 0x0f, 0xde, 0x1d,
	0xb8, 0x4d, 0x40, 0x2f, 0xaa, 0x3e, 0xfc, 0x2f, 0xf5, 0xa1, 0xb9, 0x86, 0xf2, 0xb6, 0x03, 0xed,
	0x5b, 0xdb, 0xfe, 0x8b, 0x25, 0x1c, 0xea, 0x6b, 0xd1, 0xee, 0x7d, 0x48, 0x2e, 0xe2, 0x45, 0x70,
	0x80, 0x7a, 0x00, 0x1f, 0x92, 0x8b, 0xd9, 0x55, 0x8c, 0x67, 0xf1, 0x22, 0xf0, 0xd0, 0x29, 0x74,
	0x2f, 0x93, 0xe5, 0x24, 0x76, 0x01, 0x5f, 0x07, 0x2e, 0xe6, 0xef, 0xaf, 0x92, 0xc5, 0xea, 0x57,
	0x9c, 0x24, 0x41, 0x43, 0x7f, 0x31, 0x8d, 0x67, 0xf8, 0xa3, 0xc5, 0x87, 0xe3, 0x3f, 0x3d, 0xbd,
	0xf2, 0x44, 0xa6, 0x37, 0x6e, 0xe5, 0x7f, 0xd0, 0x6b, 0xaa, 0x31, 0xda, 0xbb, 0xec, 0x83, 0x93,
	0x47, 0x51, 0x34, 0x85, 0xd3, 0xc7, 0x2e, 0xa8, 0x2f, 0x7c, 0xf7, 0x34, 0xda, 0xef, 0xd6, 0xc8,
	0x7b, 0xe5, 0xad, 0x5b, 0xc6, 0xea, 0x1f, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0xf6, 0x01, 0x32,
	0x4e, 0x25, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// SearchOrdersClient is the client API for SearchOrders service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SearchOrdersClient interface {
	// Defining rpc for unary operations
	// We can reference a nested message using the notation parent.message
	Search(ctx context.Context, in *ServerOrders_Server, opts ...grpc.CallOption) (*ServerOrders, error)
	// Defining streaming RPCs can be done by appending the keyword stream to a message type
	SubscribeOrders(ctx context.Context, opts ...grpc.CallOption) (SearchOrders_SubscribeOrdersClient, error)
}

type searchOrdersClient struct {
	cc grpc.ClientConnInterface
}

func NewSearchOrdersClient(cc grpc.ClientConnInterface) SearchOrdersClient {
	return &searchOrdersClient{cc}
}

func (c *searchOrdersClient) Search(ctx context.Context, in *ServerOrders_Server, opts ...grpc.CallOption) (*ServerOrders, error) {
	out := new(ServerOrders)
	err := c.cc.Invoke(ctx, "/SearchOrders/Search", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchOrdersClient) SubscribeOrders(ctx context.Context, opts ...grpc.CallOption) (SearchOrders_SubscribeOrdersClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SearchOrders_serviceDesc.Streams[0], "/SearchOrders/SubscribeOrders", opts...)
	if err != nil {
		return nil, err
	}
	x := &searchOrdersSubscribeOrdersClient{stream}
	return x, nil
}

type SearchOrders_SubscribeOrdersClient interface {
	Send(*ServerOrders_Server) error
	Recv() (*SubscribeOrderResponse, error)
	grpc.ClientStream
}

type searchOrdersSubscribeOrdersClient struct {
	grpc.ClientStream
}

func (x *searchOrdersSubscribeOrdersClient) Send(m *ServerOrders_Server) error {
	return x.ClientStream.SendMsg(m)
}

func (x *searchOrdersSubscribeOrdersClient) Recv() (*SubscribeOrderResponse, error) {
	m := new(SubscribeOrderResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SearchOrdersServer is the server API for SearchOrders service.
type SearchOrdersServer interface {
	// Defining rpc for unary operations
	// We can reference a nested message using the notation parent.message
	Search(context.Context, *ServerOrders_Server) (*ServerOrders, error)
	// Defining streaming RPCs can be done by appending the keyword stream to a message type
	SubscribeOrders(SearchOrders_SubscribeOrdersServer) error
}

// UnimplementedSearchOrdersServer can be embedded to have forward compatible implementations.
type UnimplementedSearchOrdersServer struct {
}

func (*UnimplementedSearchOrdersServer) Search(ctx context.Context, req *ServerOrders_Server) (*ServerOrders, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (*UnimplementedSearchOrdersServer) SubscribeOrders(srv SearchOrders_SubscribeOrdersServer) error {
	return status1.Errorf(codes.Unimplemented, "method SubscribeOrders not implemented")
}

func RegisterSearchOrdersServer(s *grpc.Server, srv SearchOrdersServer) {
	s.RegisterService(&_SearchOrders_serviceDesc, srv)
}

func _SearchOrders_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServerOrders_Server)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchOrdersServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/SearchOrders/Search",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchOrdersServer).Search(ctx, req.(*ServerOrders_Server))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchOrders_SubscribeOrders_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SearchOrdersServer).SubscribeOrders(&searchOrdersSubscribeOrdersServer{stream})
}

type SearchOrders_SubscribeOrdersServer interface {
	Send(*SubscribeOrderResponse) error
	Recv() (*ServerOrders_Server, error)
	grpc.ServerStream
}

type searchOrdersSubscribeOrdersServer struct {
	grpc.ServerStream
}

func (x *searchOrdersSubscribeOrdersServer) Send(m *SubscribeOrderResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *searchOrdersSubscribeOrdersServer) Recv() (*ServerOrders_Server, error) {
	m := new(ServerOrders_Server)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _SearchOrders_serviceDesc = grpc.ServiceDesc{
	ServiceName: "SearchOrders",
	HandlerType: (*SearchOrdersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Search",
			Handler:    _SearchOrders_Search_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeOrders",
			Handler:       _SearchOrders_SubscribeOrders_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "example.proto",
}
